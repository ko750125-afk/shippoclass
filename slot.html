<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SHIPPO SLOTS - Japanese Sentence Maker</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&family=Orbitron:wght@500;700;900&display=swap');

        :root {
            --color-bg: #0a0a0a;
            --color-gold: #FFD700;
            --color-gold-shine: #FFF8DC;
            --color-neon-red: #FF0033;
            --color-neon-blue: #00D4FF;
            --color-panel: rgba(20, 20, 20, 0.9);
            --font-jp: 'M PLUS Rounded 1c', sans-serif;
            --font-digit: 'Orbitron', sans-serif;
        }

        body {
            background-color: var(--color-bg);
            background-image:
                radial-gradient(circle at 50% 50%, #1a1a1a 0%, #000 100%),
                repeating-linear-gradient(45deg, rgba(255, 215, 0, 0.05) 0px, rgba(255, 215, 0, 0.05) 2px, transparent 2px, transparent 10px);
            color: white;
            font-family: var(--font-jp);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            width: 100%;
            box-sizing: border-box;
        }

        .pachinko-frame {
            border: 4px solid var(--color-gold);
            box-shadow: 0 0 10px var(--color-gold), inset 0 0 20px var(--color-gold);
            border-radius: 20px;
            background: var(--color-panel);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* REACH (RICH) State */
        .reach-active {
            animation: reach-flash 0.5s infinite alternate !important;
            border-color: var(--color-neon-red) !important;
            box-shadow: 0 0 30px var(--color-neon-red), inset 0 0 50px var(--color-neon-red) !important;
        }

        @keyframes reach-flash {
            from {
                background: var(--color-panel);
            }

            to {
                background: rgba(150, 0, 0, 0.4);
            }
        }

        /* CELEBRATION State */
        .celebration-active {
            animation: celebration-strobe 0.1s infinite !important;
        }

        @keyframes celebration-strobe {
            0% {
                background: #fff;
                box-shadow: 0 0 100px #fff;
            }

            50% {
                background: var(--color-bg);
            }

            100% {
                background: #FFD700;
                box-shadow: 0 0 100px #FFD700;
            }
        }

        .celebration-shake {
            animation: shake 0.2s infinite;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .neon-text-red {
            color: #fff;
            text-shadow: 0 0 5px var(--color-neon-red), 0 0 10px var(--color-neon-red), 0 0 20px var(--color-neon-red);
        }

        .neon-text-gold {
            color: var(--color-gold);
            text-shadow: 0 0 5px var(--color-gold), 0 0 10px var(--color-gold);
        }

        button {
            cursor: pointer;
            font-family: var(--font-jp);
            transition: all 0.2s ease;
        }

        /* Coin Wallet UI */
        .coin-wallet {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--color-gold);
            padding: 8px 15px;
            border-radius: 20px;
            color: var(--color-gold);
            font-family: var(--font-digit);
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
            text-shadow: 0 0 5px var(--color-gold);
        }

        .coin-icon {
            font-size: 1.3rem;
            animation: coin-bounce 2s infinite ease-in-out;
        }

        @keyframes coin-bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-3px);
            }
        }

        .coin-animation {
            animation: coin-plus 0.5s ease-out;
        }

        @keyframes coin-plus {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
                color: white;
            }

            100% {
                transform: scale(1);
            }
        }

        .btn-nav {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--color-gold);
            color: var(--color-gold);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            text-decoration: none;
            display: inline-block;
        }

        .btn-nav:hover {
            background: var(--color-gold);
            color: black;
            box-shadow: 0 0 15px var(--color-gold);
        }

        .container {
            width: 100%;
            max-width: 600px;
            /* Constrain for mobile balance */
            padding: 1rem 0;
            box-sizing: border-box;
            margin: 0 auto;
        }

        .header-title {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 1rem;
            font-weight: 900;
        }

        .slot-machine {
            background: linear-gradient(180deg, #2a2a2a 0%, #000 100%);
            border: 8px solid var(--color-gold);
            border-radius: 30px;
            padding: 30px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.2);
            position: relative;
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
        }

        .reels-container {
            display: flex;
            gap: 15px;
            background: #000;
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #555;
            box-shadow: inset 0 0 20px #000;
            margin-bottom: 10px;
            position: relative;
            overflow: hidden;
        }

        .reel-window {
            flex: 1;
            height: 200px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .reel-tape {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
        }

        .reel-item {
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            color: black;
            border-bottom: 1px solid #eee;
            box-sizing: border-box;
            padding: 10px;
            text-align: center;
        }

        .reel-item .kanji {
            font-size: 2.2rem;
            color: #d00;
            margin-bottom: 5px;
            width: 100%;
            text-align: center;
        }

        .reel-item .kana {
            font-size: 1rem;
            color: #666;
            margin-bottom: 2px;
        }

        .reel-item .meaning {
            font-size: 0.9rem;
            color: #666;
            display: none;
            /* Hide meaning in reels for cleaner look */
        }

        .controls-area {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-end;
            margin-top: 20px;
        }

        #start-lever {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ff4444, #990000);
            border: 4px solid var(--color-gold-shine);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            font-size: 1rem;
            color: white;
            font-weight: 900;
        }

        #start-lever:active {
            transform: scale(0.95);
        }

        #start-lever:disabled {
            filter: grayscale(1);
            cursor: not-allowed;
        }

        .stop-buttons {
            display: flex;
            gap: 15px;
            flex: 1;
            justify-content: space-around;
        }

        .btn-stop {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4444ff, #000099);
            border: 3px solid #aaf;
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            box-shadow: 0 0 10px rgba(0, 0, 255, 0.5);
        }

        .btn-stop:disabled {
            background: #333;
            border-color: #555;
            box-shadow: none;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .status-display {
            background: black;
            border: 2px solid var(--color-neon-red);
            padding: 10px;
            text-align: center;
            margin-bottom: 10px;
            border-radius: 10px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-text {
            font-family: var(--font-digit);
            font-size: 1.5rem;
            color: var(--color-neon-red);
            text-shadow: 0 0 10px var(--color-neon-red);
        }

        /* Shippo Character removed from Slot Page as requested */

        .character-area::after {
            content: 'ğŸ˜¸';
            position: absolute;
            font-size: 3rem;
            opacity: 0;
            z-index: -1;
        }

        #shippo-rope-container {
            display: none;
        }

        .failed-sentence {
            text-decoration: line-through var(--color-neon-red) 4px !important;
            opacity: 0.8;
            transition: all 0.3s ease;
        }



        /* Result Items */
        .result-item {
            position: absolute;
            bottom: 0px;
            right: 120px;
            font-size: 5rem;
            z-index: 21;
            display: none;
            animation: item-bounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes item-bounce {
            0% {
                transform: scale(0) rotate(-45deg);
                opacity: 0;
            }

            70% {
                transform: scale(1.2) rotate(10deg);
                opacity: 1;
            }

            100% {
                transform: scale(1) rotate(0);
            }
        }

        .feedback-area {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            display: none;
        }

        .correct-sentence {
            color: #00ff88;
            font-weight: bold;
        }

        .wrong-sentence {
            color: #ff4444;
            text-decoration: line-through;
            margin-right: 10px;
        }

        /* --- MOBILE RESPONSIVENESS --- */
        @media (max-width: 600px) {
            .container {
                padding: 1rem 0.5rem;
                margin-top: 10px;
            }

            .slot-machine {
                padding: 15px;
                border: 4px solid var(--color-gold);
                border-radius: 15px;
            }

            .header-title {
                font-size: 1.8rem;
            }

            .reels-container {
                gap: 8px;
                padding: 8px;
                margin-bottom: 5px;
            }

            .reel-item .kanji {
                font-size: 1.1rem !important;
                /* Force smaller size on mobile */
            }

            .reel-item .kana,
            .reel-item .meaning {
                display: none !important;
            }

            .reel-item .kana {
                display: none;
                /* Hide Reading in reels to save space and avoid overlap */
            }

            .reel-item .kanji {
                font-size: 1.1rem !important;
                /* Smaller text for long words */
                width: 100%;
                word-break: break-all;
            }

            .reel-item .meaning {
                font-size: 0.7rem;
            }

            .status-display {
                min-height: 40px;
                padding: 5px;
            }

            .status-text {
                font-size: 1rem;
            }

            .character-area {
                width: 100px;
                height: 100px;
                top: -60px;
                right: 0px;
                border-width: 3px;
            }

            .shippo-label {
                font-size: 0.7rem;
                padding: 3px 10px;
                bottom: -10px;
            }

            .coin-wallet {
                top: 5px;
                right: 5px;
                font-size: 0.8rem;
                padding: 4px 8px;
            }

            #start-lever {
                width: 60px;
                height: 60px;
                font-size: 0.8rem;
            }

            .btn-stop {
                width: 45px;
                height: 45px;
                font-size: 0.7rem;
            }

            .controls-area {
                gap: 10px;
            }

            .result-item {
                font-size: 3rem;
                right: 60px;
            }

            #result-meaning {
                font-size: 1rem !important;
            }

            .reel-item .kanji {
                font-size: 1.4rem !important;
                white-space: nowrap;
            }

            .reel-item .kana,
            .reel-item .meaning {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div class="container"
        style="padding: 0; width: 100%; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; margin: 0 auto; overflow: hidden;">
        <!-- Dedicated Header for Buttons to avoid overlap -->
        <div
            style="display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; width: 100%; max-width: 500px; box-sizing: border-box;">
            <a href="index.html" class="btn-nav neon-text-gold"
                style="font-size: 0.9rem; padding: 5px 12px; border-width: 2px;">â† LOBBY</a>
            <div class="coin-wallet-mobile" id="coin-wallet"
                style="background: rgba(0, 0, 0, 0.8); border: 2px solid var(--color-gold); padding: 5px 12px; border-radius: 20px; color: var(--color-gold); font-family: var(--font-digit); display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1rem;">ğŸ’°</span>
                <span id="coin-count" style="font-size: 1rem;">0</span>
            </div>
        </div>

        <div class="slot-machine" id="machine-frame" style="margin: 0 auto; position: relative;">


            <!-- Shippo Character removed from here -->



            <div id="result-item" class="result-item"></div>

            <div class="status-display">
                <span id="status-text" class="status-text">INSERT COINS (Click Start)</span>
            </div>

            <div class="reels-container">
                <div class="reel-window">
                    <div class="reel-tape" id="reel-1"></div>
                </div>
                <div class="reel-window">
                    <div class="reel-tape" id="reel-2"></div>
                </div>
                <div class="reel-window">
                    <div class="reel-tape" id="reel-3"></div>
                </div>
            </div>

        </div>

        <div class="controls-area">
            <div class="stop-buttons">
                <button class="btn-stop" id="stop-1" disabled>STOP 1</button>
                <button class="btn-stop" id="stop-2" disabled>STOP 2</button>
                <button class="btn-stop" id="stop-3" disabled>STOP 3</button>
            </div>
            <button id="start-lever">START</button>
        </div>

        <div style="text-align:center; margin-top:20px;">
            <p id="result-meaning" style="color: #aaa; font-size: 1.2rem; min-height: 1.5rem;"></p>
            <div id="feedback-area" class="feedback-area">
                <div id="feedback-content"></div>
            </div>
        </div>
    </div>
    </div>

    <!-- INLINED JS LOGIC ONLY - NO EXTERNAL SCRIPTS -->
    <script>
        // Pre-load voices for SpeechSynthesis
        let jaVoice = null;
        function loadVoices() {
            const voices = window.speechSynthesis.getVoices();
            jaVoice = voices.find(v => v.lang.includes('ja')) || null;
        }
        if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = loadVoices;
            loadVoices();
        }
        // --- Utils ---
        const Utils = {
            speak: (text) => {
                if (!window.speechSynthesis) return;
                window.speechSynthesis.cancel();

                let speechText = text;
                let rate = 0.8;
                let pitch = 1.0;

                const oDan = ['ãŠ', 'ã“', 'ã', 'ã¨', 'ã®', 'ã»', 'ã‚‚', 'ã‚ˆ', 'ã‚', 'ã‚’', 'ã”', 'ã', 'ã©', 'ã¼', 'ã½'];
                const uDan = ['ã†', 'ã', 'ã™', 'ã¤', 'ã¬', 'ãµ', 'ã‚€', 'ã‚†', 'ã‚‹', 'ã', 'ãš', 'ã¥', 'ã¶', 'ã·'];

                const oDanFixed = ['ãŠ', 'ã“', 'ã', 'ã¨', 'ã®', 'ã»', 'ã©', 'ã¼', 'ã½'];
                const uDanFixed = ['ã†', 'ã', 'ã™', 'ã¤', 'ã¬', 'ãµ', 'ã‚€', 'ã‚†', 'ã‚‹', 'ã', 'ãš', 'ã¥', 'ã¶', 'ã·'];

                const oDanFinal = ['ãŠ', 'ã“', 'ã', 'ã¨', 'ã®', 'ã»', 'ã‚‚', 'ã‚ˆ', 'ã‚', 'ã‚’', 'ã”', 'ã', 'ã©', 'ã¼', 'ã½'];
                const uDanFinal = ['ã†', 'ã', 'ã™', 'ã¤', 'ã¬', 'ãµ', 'ã‚€', 'ã‚†', 'ã‚‹', 'ã', 'ãš', 'ã¥', 'ã¶', 'ã·'];

                if (oDanFinal.includes(text)) {
                    speechText = text + 'ãƒ¼ãƒ¼';
                    rate = 0.5;
                    pitch = 1.3;
                } else if (uDanFinal.includes(text)) {
                    speechText = text + 'ãƒ¼ãƒ¼';
                    rate = 0.5;
                    pitch = 1.2;
                } else if (text.length === 1) {
                    speechText = text + 'ãƒ¼';
                }

                const utterance = new SpeechSynthesisUtterance(speechText);
                if (!jaVoice) loadVoices();
                if (jaVoice) utterance.voice = jaVoice;
                utterance.lang = 'ja-JP';
                utterance.rate = rate;
                utterance.pitch = pitch;
                utterance.volume = 1.0;
                window.speechSynthesis.speak(utterance);
            },
            // Web Audio API Sound
            playSound: (type) => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                if (!window.slotAudioCtx) {
                    window.slotAudioCtx = new AudioContext();
                }
                const ctx = window.slotAudioCtx;
                if (ctx.state === 'suspended') ctx.resume();
                const now = ctx.currentTime;

                if (type === 'spin_loop') {
                    if (window.currentSpinOsc) {
                        try { window.currentSpinOsc.osc.stop(); window.currentSpinOsc.lfo.stop(); } catch (e) { }
                    }

                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const lfo = ctx.createOscillator();
                    const lfoGain = ctx.createGain();

                    // Strong but clear mechanical sound
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(110, now);

                    lfo.type = 'sine';
                    lfo.frequency.value = 12;
                    lfoGain.gain.value = 40;

                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    osc.connect(gain);
                    gain.connect(ctx.destination);

                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.6, now + 0.1); // High Volume

                    osc.start(now);
                    lfo.start(now);
                    window.currentSpinOsc = { osc, gain, lfo };
                    return;
                }

                if (type === 'spin_stop') {
                    if (window.currentSpinOsc) {
                        const { osc, gain, lfo } = window.currentSpinOsc;
                        gain.gain.setValueAtTime(gain.gain.value, now);
                        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
                        osc.stop(now + 0.3);
                        lfo.stop(now + 0.3);
                        window.currentSpinOsc = null;
                    }
                    return;
                }

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                if (type === 'win') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(880, now);
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.8, now + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                    osc.start(now);
                    osc.stop(now + 0.8);

                    const osc2 = ctx.createOscillator();
                    const gain2 = ctx.createGain();
                    osc2.connect(gain2); gain2.connect(ctx.destination);
                    osc2.type = 'sine'; osc2.frequency.setValueAtTime(1175, now + 0.15);
                    gain2.gain.setValueAtTime(0, now + 0.15);
                    gain2.gain.linearRampToValueAtTime(0.8, now + 0.16);
                    gain2.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
                    osc2.start(now + 0.15); osc2.stop(now + 1.2);
                } else if (type === 'stop') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(180, now);
                    gain.gain.setValueAtTime(0.6, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'click' || type === 'spin') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, now);
                    osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                    gain.gain.setValueAtTime(0.6, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                    osc.start(now);
                    osc.stop(now + 0.05);
                } else if (type === 'error') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(330, now);
                    gain.gain.setValueAtTime(0.6, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.3);
                    osc.start(now);
                    osc.stop(now + 0.3);
                } else if (type === 'siren') {
                    // Pulsing Siren for Reach tension
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(440, now);
                    osc.frequency.exponentialRampToValueAtTime(880, now + 0.5);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.linearRampToValueAtTime(0.3, now + 0.25);
                    gain.gain.linearRampToValueAtTime(0, now + 0.5);
                    osc.start(now);
                    osc.stop(now + 0.5);
                }
            },

            randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min
        };

        // --- Slot Data ---
        let slotData = null;
        /*
        const slotData = {
            "subjects": [
                { "text": "ã‚ãŸã—ã¯", "kanji": "ç§ã¯", "meaning": "ë‚˜ëŠ”" },
                { "text": "ã¡ã¡ã¯", "kanji": "çˆ¶ã¯", "meaning": "ì•„ë¹ ëŠ”" },
                { "text": "ã¯ã¯ã¯", "kanji": "æ¯ã¯", "meaning": "ì—„ë§ˆëŠ”" },
                { "text": "ã¨ã‚‚ã ã¡ã¯", "kanji": "å‹ã ã¡ã¯", "meaning": "ì¹œêµ¬ëŠ”" },
                { "text": "ãŒãã›ã„ã¯", "kanji": "å­¦ç”Ÿã¯", "meaning": "í•™ìƒì€" },
                { "text": "ã›ã‚“ã›ã„ã¯", "kanji": "å…ˆç”Ÿã¯", "meaning": "ì„ ìƒë‹˜ì€" },
                { "text": "ã“ã©ã‚‚ã¯", "kanji": "å­ã©ã‚‚ã¯", "meaning": "ì•„ì´ëŠ”" },
                { "text": "ã‹ã„ã—ã‚ƒã„ã‚“ã¯", "kanji": "ä¼šç¤¾å“¡ã¯", "meaning": "íšŒì‚¬ì›ì€" },
                { "text": "ã¦ã‚“ã„ã‚“ã¯", "kanji": "åº—å“¡ã¯", "meaning": "ì ì›ì€" },
                { "text": "ãŠãã‚ƒãã•ã‚“ã¯", "kanji": "ãŠå®¢ã•ã‚“ã¯", "meaning": "ì†ë‹˜ì€" },
                { "text": "ã‹ã‚Œã¯", "kanji": "å½¼ã¯", "meaning": "ê·¸ëŠ”" },
                { "text": "ã‹ã®ã˜ã‚‡ã¯", "kanji": "å½¼å¥³ã¯", "meaning": "ê·¸ë…€ëŠ”" },
                { "text": "ã«ã»ã‚“ã˜ã‚“ã¯", "kanji": "æ—¥æœ¬äººã¯", "meaning": "ì¼ë³¸ì¸ì€" },
                { "text": "ã‹ã‚“ã“ãã˜ã‚“ã¯", "kanji": "éŸ“å›½äººã¯", "meaning": "í•œêµ­ì¸ì€" },
                { "text": "ã›ã‚“ã±ã„ã¯", "kanji": "å…ˆè¼©ã¯", "meaning": "ì„ ë°°ëŠ”" },
                { "text": "ã“ã†ã¯ã„ã¯", "kanji": "å¾Œè¼©ã¯", "meaning": "í›„ë°°ëŠ”" },
                { "text": "ã©ã†ã‚Šã‚‡ã†ã¯", "kanji": "åŒåƒšã¯", "meaning": "ë™ë£ŒëŠ”" },
                { "text": "ã‚ã«ã¯", "kanji": "å…„ã¯", "meaning": "í˜•/ì˜¤ë¹ ëŠ”" },
                { "text": "ã‚ã­ã¯", "kanji": "å§‰ã¯", "meaning": "ëˆ„ë‚˜/ì–¸ë‹ˆëŠ”" },
                { "text": "ã¨ãªã‚Š ã® ã²ã¨ ã¯", "kanji": "éš£ã®äººã¯", "meaning": "ì˜†ì§‘ ì‚¬ëŒì€" }
            ],
            "objects": {
                "ãƒ©ãƒ¼ãƒ¡ãƒ³ã‚’": { "meaning": "ë¼ë©´ì„", "verbs": ["é£Ÿã¹ã¾ã—ãŸ", "ä½œã‚Šã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "å¯¿å¸ã‚’": { "meaning": "ì´ˆë°¥ì„", "verbs": ["é£Ÿã¹ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "ä½œã‚Šã¾ã—ãŸ"] },
                "ã”é£¯ã‚’": { "meaning": "ë°¥ì„", "verbs": ["é£Ÿã¹ã¾ã—ãŸ", "ä½œã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "ãƒ‘ãƒ³ã‚’": { "meaning": "ë¹µì„", "verbs": ["é£Ÿã¹ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "ä½œã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’": { "meaning": "ì»¤í”¼ë¥¼", "verbs": ["é£²ã¿ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "ãŠèŒ¶ã‚’": { "meaning": "ì°¨ë¥¼", "verbs": ["é£²ã¿ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "æ°´ã‚’": { "meaning": "ë¬¼ì„", "verbs": ["é£²ã¿ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "æ—¥æœ¬èªã‚’": { "meaning": "ì¼ë³¸ì–´ë¥¼", "verbs": ["å‹‰å¼·ã—ã¾ã—ãŸ", "ç¿’ã„ã¾ã—ãŸ", "æ•™ãˆã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "æ›¸ãã¾ã—ãŸ", "èãã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ"] },
                "è‹±èªã‚’": { "meaning": "ì˜ì–´ë¥¼", "verbs": ["å‹‰å¼·ã—ã¾ã—ãŸ", "ç¿’ã„ã¾ã—ãŸ", "æ•™ãˆã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "æ›¸ãã¾ã—ãŸ", "èãã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ"] },
                "å®¿é¡Œã‚’": { "meaning": "ìˆ™ì œë¥¼", "verbs": ["ã—ã¾ã—ãŸ", "ç¢ºèªã—ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "æ›¸ãã¾ã—ãŸ"] },
                "ä»•äº‹ã‚’": { "meaning": "ì¼ì„", "verbs": ["ã—ã¾ã—ãŸ", "ç¢ºèªã—ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "æœ¬ã‚’": { "meaning": "ì±…ì„", "verbs": ["èª­ã¿ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "æ˜ ç”»ã‚’": { "meaning": "ì˜í™”ë¥¼", "verbs": ["è¦‹ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ"] },
                "ãƒ†ãƒ¬ãƒ“ã‚’": { "meaning": "TVë¥¼", "verbs": ["è¦‹ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ"] },
                "éŸ³æ¥½ã‚’": { "meaning": "ìŒì•…ì„", "verbs": ["èãã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "è²·ã„ã¾ã—ãŸ"] },
                "ãƒ¡ãƒ¼ãƒ«ã‚’": { "meaning": "ë©”ì¼ì„", "verbs": ["æ›¸ãã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "ã‚‚ã‚‰ã„ã¾ã—ãŸ", "èª­ã¿ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "ç¢ºèªã—ã¾ã—ãŸ"] },
                "æ‰‹ç´™ã‚’": { "meaning": "í¸ì§€ë¥¼", "verbs": ["æ›¸ãã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "ã‚‚ã‚‰ã„ã¾ã—ãŸ", "èª­ã¿ã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "ç¢ºèªã—ã¾ã—ãŸ"] },
                "æœã‚’": { "meaning": "ì˜·ì„", "verbs": ["è²·ã„ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "ä½œã‚Šã¾ã—ãŸ"] },
                "é´ã‚’": { "meaning": "ì‹ ë°œì„", "verbs": ["è²·ã„ã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ"] },
                "å†™çœŸã‚’": { "meaning": "ì‚¬ì§„ì„", "verbs": ["æ’®ã‚Šã¾ã—ãŸ", "è¦‹ã¾ã—ãŸ", "é€ã‚Šã¾ã—ãŸ", "é¸ã³ã¾ã—ãŸ", "ã‚‚ã‚‰ã„ã¾ã—ãŸ"] }
            },
            "verbs": [
                { "text": "ãŸã¹ã¾ã—ãŸ", "kanji": "é£Ÿã¹ã¾ã—ãŸ", "meaning": "ë¨¹ì—ˆìŠµë‹ˆë‹¤" },
                { "text": "ã®ã¿ã¾ã—ãŸ", "kanji": "é£²ã¿ã¾ã—ãŸ", "meaning": "ë§ˆì…¨ìŠµë‹ˆë‹¤" },
                { "text": "ã¿ã¾ã—ãŸ", "kanji": "è¦‹ã¾ã—ãŸ", "meaning": "ë³´ì•˜ìŠµë‹ˆë‹¤" },
                { "text": "ã‚ˆã¿ã¾ã—ãŸ", "kanji": "èª­ã¿ã¾ã—ãŸ", "meaning": "ì½ì—ˆìŠµë‹ˆë‹¤" },
                { "text": "ããã¾ã—ãŸ", "kanji": "èãã¾ã—ãŸ", "meaning": "ë“¤ì—ˆìŠµë‹ˆë‹¤" },
                { "text": "ã‹ãã¾ã—ãŸ", "kanji": "æ›¸ãã¾ã—ãŸ", "meaning": "ì¼ìŠµë‹ˆë‹¤" },
                { "text": "ã‹ã„ã¾ã—ãŸ", "kanji": "è²·ã„ã¾ã—ãŸ", "meaning": "ìƒ€ìŠµë‹ˆë‹¤" },
                { "text": "ã¤ãã‚Šã¾ã—ãŸ", "kanji": "ä½œã‚Šã¾ã—ãŸ", "meaning": "ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤" },
                { "text": "ã¹ã‚“ãã‚‡ã†ã—ã¾ã—ãŸ", "kanji": "å‹‰å¼·ã—ã¾ã—ãŸ", "meaning": "ê³µë¶€í–ˆìŠµë‹ˆë‹¤" },
                { "text": "ãªã‚‰ã„ã¾ã—ãŸ", "kanji": "ç¿’ã„ã¾ã—ãŸ", "meaning": "ë°°ì› ìŠµë‹ˆë‹¤" },
                { "text": "ãŠã—ãˆã¾ã—ãŸ", "kanji": "æ•™ãˆã¾ã—ãŸ", "meaning": "ê°€ë¥´ì³¤ìŠµë‹ˆë‹¤" },
                { "text": "ãŠãã‚Šã¾ã—ãŸ", "kanji": "é€ã‚Šã¾ã—ãŸ", "meaning": "ë³´ëƒˆìŠµë‹ˆë‹¤" },
                { "text": "ã‚‚ã‚‰ã„ã¾ã—ãŸ", "kanji": "ã‚‚ã‚‰ã„ã¾ã—ãŸ", "meaning": "ë°›ì•˜ìŠµë‹ˆë‹¤" },
                { "text": "ã‹ãã«ã‚“ã—ã¾ã—ãŸ", "kanji": "ç¢ºèªã—ã¾ã—ãŸ", "meaning": "í™•ì¸í–ˆìŠµë‹ˆë‹¤" },
                { "text": "ã—ã¾ã—ãŸ", "kanji": "ã—ã¾ã—ãŸ", "meaning": "í–ˆìŠµë‹ˆë‹¤" },
                { "text": "ãˆã‚‰ã³ã¾ã—ãŸ", "kanji": "é¸ã³ã¾ã—ãŸ", "meaning": "ê³ ë¥´ê±°ë‚˜ ì„ íƒí–ˆìŠµë‹ˆë‹¤" },
                { "text": "ã¨ã‚Šã¾ã—ãŸ", "kanji": "æ’®ã‚Šã¾ã—ãŸ", "meaning": "ì°ì—ˆìŠµë‹ˆë‹¤" }
            ],
            "failEvents": [
                { "type": "crocodile", "emoji": "ğŸŠ", "prob": 0.3 },
                { "type": "can", "emoji": "ğŸ¥«", "prob": 0.2 },
                { "type": "fish", "emoji": "ğŸŸ", "prob": 0.2 },
                { "type": "shoe", "emoji": "ğŸ‘Ÿ", "prob": 0.15 },
                { "type": "ropeBreak", "emoji": "ğŸ’¥", "prob": 0.15 }
            ]
        };
        */

        // --- Game Logic ---
        let REEL_HEIGHT = 200; // Will be updated dynamically on load
        const SPIN_SPEED = 15;

        let reels = [[], [], []];
        let reelElements = [null, null, null];
        let spinIntervals = [null, null, null];
        let reelOffsets = [0, 0, 0];
        let stopping = [false, false, false];
        let finalResult = [null, null, null];
        let stopCount = 0;
        let isRich = false;
        let sirenInterval = null;
        let userCoins = 0;

        // Elements
        let statusText, machineFrame, resultMeaning, charFace, resultItem, feedbackArea, feedbackContent, coinCountDisplay;

        window.onload = function () {
            statusText = document.getElementById('status-text');
            machineFrame = document.getElementById('machine-frame');
            resultMeaning = document.getElementById('result-meaning');
            charFace = document.getElementById('char-face');
            coinCountDisplay = document.getElementById('coin-count');
            resultItem = document.getElementById('result-item');
            feedbackArea = document.getElementById('feedback-area');
            feedbackContent = document.getElementById('feedback-content');

            // Initial height check
            REEL_HEIGHT = (window.innerWidth <= 600) ? 120 : 200;

            // Load Coins from LocalStorage
            const savedCoins = localStorage.getItem('shippo_coins');
            if (savedCoins) {
                userCoins = parseInt(savedCoins);
                updateCoinUI(false);
            }

            reelElements = [
                document.getElementById('reel-1'),
                document.getElementById('reel-2'),
                document.getElementById('reel-3')
            ];

            // Load external data
            fetch('data/slots.json')
                .then(response => response.json())
                .then(data => {
                    slotData = data;
                    initGame();
                })
                .catch(err => {
                    console.error('Data load error:', err);
                    statusText.textContent = "Error: JSON data could not be loaded.";
                });

            // Keyboard Controls
            document.addEventListener('keydown', (e) => {
                if (e.repeat) return;

                const isSpinning = spinIntervals.some(i => i !== null);

                if (e.code === 'Space' || e.code === 'Enter') {
                    e.preventDefault();
                    if (!isSpinning) {
                        // Gesture resume
                        if (window.slotAudioCtx && window.slotAudioCtx.state === 'suspended') {
                            window.slotAudioCtx.resume();
                        }
                        Utils.playSound('click');
                        startSpin();
                    } else {
                        // Smart Stop: stop next available spinning reel
                        const nextIdx = spinIntervals.findIndex(i => i !== null);
                        if (nextIdx !== -1) stopReel(nextIdx);
                    }
                    return;
                }

                // Arrow keys for Stopping
                if (isSpinning) {
                    if (e.code === 'ArrowLeft') stopReel(0);
                    if (e.code === 'ArrowDown') stopReel(1);
                    if (e.code === 'ArrowRight') stopReel(2);
                }
            });
        };

        function updateCoinUI(animate = true) {
            coinCountDisplay.textContent = userCoins.toLocaleString();
            if (animate) {
                coinCountDisplay.classList.remove('coin-animation');
                void coinCountDisplay.offsetWidth; // Trigger reflow
                coinCountDisplay.classList.add('coin-animation');
            }
            localStorage.setItem('shippo_coins', userCoins);
        }

        function addCoins(amount) {
            userCoins += amount;
            updateCoinUI(true);
            Utils.playSound('click'); // Coin clink sound
        }

        function initGame() {
            // Triple the items to allow smooth infinite loop
            const sub = [...slotData.subjects];
            reels[0] = [...sub, ...sub, ...sub];

            const objKeys = Object.keys(slotData.objects).map(key => ({
                text: key,
                kanji: key,
                meaning: slotData.objects[key].meaning
            }));
            reels[1] = [...objKeys, ...objKeys, ...objKeys];

            const vrb = [...slotData.verbs];
            reels[2] = [...vrb, ...vrb, ...vrb];

            reelElements.forEach((el, i) => renderReel(el, reels[i]));

            // Double check height after rendering content
            setTimeout(() => {
                const sample = document.querySelector('.reel-item');
                if (sample && sample.offsetHeight > 0) {
                    REEL_HEIGHT = sample.offsetHeight;
                }
            }, 100);

            document.getElementById('start-lever').addEventListener('click', () => {
                Utils.playSound('click');
                startSpin();
            });
            document.getElementById('stop-1').addEventListener('click', () => stopReel(0));
            document.getElementById('stop-2').addEventListener('click', () => stopReel(1));
            document.getElementById('stop-3').addEventListener('click', () => stopReel(2));

            // Rename buttons to Korean
            document.getElementById('stop-1').textContent = "ìŠ¤í†± 1";
            document.getElementById('stop-2').textContent = "ìŠ¤í†± 2";
            document.getElementById('stop-3').textContent = "ìŠ¤í†± 3";

            statusText.textContent = "ë™ì „ì„ ë„£ì–´ì£¼ì„¸ìš” (Start)";
        }

        function toggleStopButtons(index) {
            // Sequential activation: Only one button active at a time
            [1, 2, 3].forEach(i => {
                const btn = document.getElementById(`stop-${i}`);
                if (btn) {
                    btn.disabled = (i !== index + 1);
                    btn.style.opacity = (i === index + 1) ? 1 : 0.5;
                }
            });
        }

        function renderReel(element, items) {
            element.innerHTML = '';
            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'reel-item';
                // Remove Hangul (item.meaning) from the spinning reels as requested
                div.innerHTML = `<div class="kanji">${item.kanji}</div><div class="kana">${item.text}</div>`;
                element.appendChild(div);
            });
        }

        function startSpin() {
            if (spinIntervals.some(i => i !== null)) return;

            // Ensure AudioContext is initialized and resumed on user gesture
            if (!window.slotAudioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) window.slotAudioCtx = new AudioContext();
            }
            if (window.slotAudioCtx && window.slotAudioCtx.state === 'suspended') {
                window.slotAudioCtx.resume();
            }

            stopCount = 0;
            stopping = [false, false, false];
            isRich = false;
            if (sirenInterval) { clearInterval(sirenInterval); sirenInterval = null; }
            machineFrame.classList.remove('reach-active', 'celebration-active', 'celebration-shake');

            statusText.textContent = "ê°€ì¦ˆì•„!!!";
            statusText.className = "status-text";
            resultMeaning.textContent = "";
            resultItem.style.display = "none";
            feedbackArea.style.display = "none";
            resultMeaning.classList.remove('failed-sentence');

            toggleStopButtons(0); // Only STOP 1 active initially

            document.getElementById('start-lever').disabled = true;

            const baseSpeed = SPIN_SPEED;
            Utils.playSound('spin');
            Utils.playSound('spin_loop');

            [0, 1, 2].forEach(i => {
                spinIntervals[i] = setInterval(() => {
                    reelOffsets[i] = (reelOffsets[i] - baseSpeed) % (reels[i].length * REEL_HEIGHT);
                    reelElements[i].style.top = `${reelOffsets[i]}px`;
                }, 20);
            });
        }

        function stopReel(index) {
            if (stopping[index]) return;
            stopping[index] = true;

            const btn = document.getElementById(`stop-${index + 1}`);
            if (btn) {
                btn.disabled = true;
                btn.style.opacity = 0.5;
            }

            Utils.playSound('stop');

            if (spinIntervals[index]) {
                clearInterval(spinIntervals[index]);
                spinIntervals[index] = null;
            }

            // Real stopping logic: Land on the item currently visible in the middle
            // reelOffsets[index] is negative and decreasing. 
            // Current center item index is: Math.floor(Math.abs(reelOffsets[index] - REEL_HEIGHT) / REEL_HEIGHT) % (reels[index].length / 3)
            const baseLen = reels[index].length / 3;
            const currentAbsOffset = Math.abs(reelOffsets[index]);
            const landedIdx = Math.round(currentAbsOffset / REEL_HEIGHT) % baseLen;

            finalResult[index] = reels[index][landedIdx];

            // Stop at the middle copy for visual consistency
            const targetOffset = -(landedIdx + baseLen) * REEL_HEIGHT;
            reelElements[index].style.transition = 'top 0.4s cubic-bezier(0.17, 0.67, 0.83, 1.2)';
            reelElements[index].style.top = `${targetOffset}px`;

            stopCount++;
            reelOffsets[index] = targetOffset; // Update offset for next game start

            if (index === 0) {
                toggleStopButtons(1); // Enable STOP 2
            } else if (index === 1) {
                // Determine Reach (Rich) probability - Higher chance for exciting flow
                // Check if Subject and Object have any logical connection
                let potentialSuccess = false;
                const currentObj = finalResult[1].text;
                if (slotData.objects[currentObj]) {
                    potentialSuccess = true; // Most things are SUCCESS now, so Reach happens often
                }

                if (potentialSuccess && Math.random() < 0.7) { // 70% chance of Reach if potentially logical
                    isRich = true;
                    machineFrame.classList.add('reach-active');
                    statusText.textContent = "REACH!!! ğŸ”¥";
                    Utils.playSound('win_small'); // Initial alert

                    sirenInterval = setInterval(() => {
                        Utils.playSound('siren');
                    }, 600);

                    // Slow down 3rd reel significantly for tension
                    if (spinIntervals[2]) {
                        clearInterval(spinIntervals[2]);
                        spinIntervals[2] = setInterval(() => {
                            reelOffsets[2] = (reelOffsets[2] - (SPIN_SPEED / 10)) % (reels[2].length * REEL_HEIGHT);
                            reelElements[2].style.top = `${reelOffsets[2]}px`;
                        }, 20);
                    }
                } else {
                    // Normal slow down
                    if (spinIntervals[2]) {
                        clearInterval(spinIntervals[2]);
                        spinIntervals[2] = setInterval(() => {
                            reelOffsets[2] = (reelOffsets[2] - (SPIN_SPEED / 2.5)) % (reels[2].length * REEL_HEIGHT);
                            reelElements[2].style.top = `${reelOffsets[2]}px`;
                        }, 20);
                    }
                }
                toggleStopButtons(2); // Enable STOP 3
            } else if (index === 2) {
                if (sirenInterval) { clearInterval(sirenInterval); sirenInterval = null; }
                machineFrame.classList.remove('reach-active');
                // Delay evaluation to sync with transition end
                setTimeout(evaluate, 600);
            }
        }



        function evaluate() {
            Utils.playSound('spin_stop');
            document.getElementById('start-lever').disabled = false;

            const subject = finalResult[0];
            const object = finalResult[1];
            const verb = finalResult[2];

            // Particles are now included in the strings
            const sentence = `${subject.kanji} ${object.kanji} ${verb.kanji}`;
            const meaning = `${subject.meaning} ${object.meaning} ${verb.meaning}`;
            resultMeaning.innerHTML = `<div style="color:white; font-size:2rem; margin-bottom:5px;">${sentence}</div><div style="color:#aaa; font-size:1.2rem;">(${meaning})</div>`;

            // Always speak the formed sentence
            const speechText = sentence.replace(/ã¯/g, 'ã‚');
            setTimeout(() => Utils.speak(speechText), 500);

            const isSuccess = slotData.objects[object.kanji] && slotData.objects[object.kanji].verbs.includes(verb.kanji);

            if (isSuccess) {
                handleSuccess(sentence, subject, object, verb);
            } else {
                handleFailure(sentence, subject, object, verb, speechText);
            }
        }

        function handleSuccess(sentence, subject, object, verb) {
            statusText.textContent = "ì„±ê³µ!! ë‹¹ì²¨ì´ë‹¤!!";
            statusText.classList.add('celebration-shake');
            setFace('smile');
            Utils.playSound('win');

            if (isRich) {
                machineFrame.classList.add('celebration-active');
                statusText.textContent = "â˜…ì´ˆëŒ€ë°• ë‹¹ì²¨!!!â˜…";
                addCoins(500); // Massive Reward for Reach
                // Keep the celebration for a few seconds
                setTimeout(() => {
                    machineFrame.classList.remove('celebration-active');
                    statusText.classList.remove('celebration-shake');
                }, 4000);
            } else {
                addCoins(100); // Standard Reward
                setTimeout(() => {
                    statusText.classList.remove('celebration-shake');
                }, 2000);
            }

            // Item based on result (maybe different for objects?)
            resultItem.textContent = "ğŸ’°";
            resultItem.style.display = "block";
        }

        function handleFailure(sentence, subject, object, verb, speechText) {
            statusText.textContent = "ì—êµ¬êµ¬... ì‹¤íŒ¨!";
            setFace('angry');
            Utils.playSound('error');
            resultMeaning.classList.add('failed-sentence');

            // Pick random fail event
            const rand = Math.random();
            let accum = 0;
            let event = slotData.failEvents[0];
            for (let e of slotData.failEvents) {
                accum += e.prob;
                if (rand <= accum) {
                    event = e;
                    break;
                }
            }

            resultItem.textContent = event.emoji;
            resultItem.style.display = "block";

            // Educational Feedback
            feedbackArea.style.display = "block";
            const allowedVerbs = slotData.objects[object.kanji] ? slotData.objects[object.kanji].verbs : ["???"];
            const correctVerbText = allowedVerbs[0];
            const correctVerbObj = slotData.verbs.find(v => v.kanji === correctVerbText) || { meaning: "???" };

            feedbackContent.innerHTML = `
                <div style="font-size: 1.3rem; margin-bottom: 5px; margin-top: 10px;">
                    <span>ğŸ‘‰ </span><span class="correct-sentence">${subject.kanji} ${object.kanji} ${correctVerbText}</span> âœ…
                </div>
                <div style="color: #ccc; font-size: 0.9rem;">
                    (${subject.meaning} ${object.meaning} ${correctVerbObj.meaning})
                </div>
                <hr style="border: 0; border-top: 1px solid #444; margin: 10px 0;">
                <small style="color: #aaa;">ğŸ’¡ íŒ: [${object.kanji}] ë’¤ì—ëŠ” [${correctVerbText}] ë“±ì˜ í‘œí˜„ì´ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤.</small>
            `;
        }

        function setFace(mood) {
            if (charFace) {
                charFace.style.borderColor = (mood === 'tension' ? 'red' : (mood === 'smile' ? 'gold' : 'white'));
            }
        }
    </script>
</body>

</html>